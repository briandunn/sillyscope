{"version":3,"sources":["main.js"],"names":["require","Elm","context","AudioContext","app","Main","init","node","document","querySelector","notePress","id","frequency","attack","type","osc","createOscillator","gain","createGain","analyser","createAnalyser","connect","value","linearRampToValueAtTime","currentTime","destination","start","ports","notePressed","send","noteRelease","setTimeout","forEach","disconnect","getWaveforms","notes","requestAnimationFrame","waveforms","map","waveform","Float32Array","frequencyBinCount","getFloatTimeDomainData","Array","from","subscriptions","portName","subscribe"],"mappings":";;;AAAgBA,IAAAA,EAAAA,QAAQ,cAAhBC,EAAAA,EAAAA,IAEFC,EAAU,IAAIC,aAEdC,EAAMH,EAAII,KAAKC,KAAK,CACxBC,KAAMC,SAASC,cAAc,UAG/B,SAASC,EAA2C,GAA/BC,IAAAA,EAAAA,EAAAA,GAAIC,EAAAA,EAAAA,UAAWC,EAAAA,EAAAA,OAAQC,EAAAA,EAAAA,KACpCC,EAAMb,EAAQc,mBACdC,EAAOf,EAAQgB,aACfC,EAAWjB,EAAQkB,iBACzBL,EAAIM,QAAQJ,GACZF,EAAIH,UAAUU,MAAQV,EACtBK,EAAKA,KAAKK,MAAQ,EAClBL,EAAKA,KAAKM,wBAAwB,GAAKrB,EAAQsB,YAAcX,GAC7DI,EAAKI,QAAQnB,EAAQuB,aACrBV,EAAIM,QAAQF,GACZJ,EAAID,KAAOA,EACXC,EAAIW,MAAM,GAEVtB,EAAIuB,MAAMC,YAAYC,KAAK,CACzBlB,GAAAA,EACAC,UAAAA,EACAC,OAAAA,EACAN,KAAM,CACJY,SAAAA,EACAF,KAAAA,EACAF,IAAAA,KAKN,SAASe,EAAuD,GAAzCjB,IAAAA,EAAAA,EAAAA,OAAQN,EAAAA,EAAAA,KAAQU,EAAAA,EAAAA,KAAMF,EAAAA,EAAAA,IAAKI,EAAAA,EAAAA,SAChDF,EAAKA,KAAKM,wBAAwB,EAAGrB,EAAQsB,YAAcX,GAC3DkB,WAAW,WACRd,CAAAA,EAAMF,EAAKI,GAAUa,QAAQ,SAAAzB,GAC5BA,EAAK0B,gBAEG,IAATpB,GAGL,SAASqB,EAAaC,GACpBC,sBAAsB,WACdC,IAAAA,EAAYF,EAAMG,IAAI,SAAgC,GAA7B3B,IAAAA,EAAAA,EAAAA,GAAYQ,EAARZ,EAAAA,KAAQY,SACnCoB,EAAW,IAAIC,aAAarB,EAASsB,mBAEpC,OADPtB,EAASuB,uBAAuBH,GACzB,CAAE5B,GAAAA,EAAI4B,SAAUI,MAAMC,KAAKL,MAGpCnC,EAAIuB,MAAMU,UAAUR,KAAKQ,KAI7B,IAAMQ,EAAgB,CACpBnC,UAAAA,EACAoB,YAAAA,EACAI,aAAAA,GAGF,IAAK,IAAMY,KAAYD,EACrBzC,EAAIuB,MAAMmB,GAAUC,UAAUF,EAAcC","file":"main.0226fb78.map","sourceRoot":"../src","sourcesContent":["const { Elm } = require('./Main.elm');\n\nconst context = new AudioContext();\n\nconst app = Elm.Main.init({\n  node: document.querySelector('main'),\n});\n\nfunction notePress({ id, frequency, attack, type }) {\n  const osc = context.createOscillator();\n  const gain = context.createGain();\n  const analyser = context.createAnalyser();\n  osc.connect(gain);\n  osc.frequency.value = frequency;\n  gain.gain.value = 0;\n  gain.gain.linearRampToValueAtTime(0.5, context.currentTime + attack);\n  gain.connect(context.destination);\n  osc.connect(analyser);\n  osc.type = type;\n  osc.start(0);\n\n  app.ports.notePressed.send({\n    id,\n    frequency,\n    attack,\n    node: {\n      analyser,\n      gain,\n      osc,\n    },\n  });\n}\n\nfunction noteRelease({ attack, node: { gain, osc, analyser } }) {\n  gain.gain.linearRampToValueAtTime(0, context.currentTime + attack);\n  setTimeout(() => {\n    [gain, osc, analyser].forEach(node => {\n      node.disconnect();\n    });\n  }, attack * 1000);\n}\n\nfunction getWaveforms(notes) {\n  requestAnimationFrame(() => {\n    const waveforms = notes.map(({ id, node: { analyser } }) => {\n      const waveform = new Float32Array(analyser.frequencyBinCount);\n      analyser.getFloatTimeDomainData(waveform);\n      return { id, waveform: Array.from(waveform) };\n    });\n\n    app.ports.waveforms.send(waveforms);\n  });\n}\n\nconst subscriptions = {\n  notePress,\n  noteRelease,\n  getWaveforms,\n};\n\nfor (const portName in subscriptions) {\n  app.ports[portName].subscribe(subscriptions[portName]);\n}\n"]}